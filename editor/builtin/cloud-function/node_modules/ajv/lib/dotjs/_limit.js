"use strict";module.exports=function(e,r,a){var t,s=" ",o=e.level,i=e.dataLevel,m=e.schema[r],h=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,l=!e.opts.allErrors,d="data"+(i||""),n=e.opts.$data&&m&&m.$data;n?(s+=" var schema"+o+" = "+e.util.getData(m.$data,i,e.dataPathArr)+"; ",t="schema"+o):t=m;var c="maximum"==r,v=c?"exclusiveMaximum":"exclusiveMinimum",p=e.schema[v],f=e.opts.$data&&p&&p.$data,b=c?"<":">",P=c?">":"<",E=void 0;if(!n&&"number"!=typeof m&&void 0!==m)throw new Error(r+" must be number");if(!f&&void 0!==p&&"number"!=typeof p&&"boolean"!=typeof p)throw new Error(v+" must be number or boolean");if(f){var y=e.util.getData(p.$data,i,e.dataPathArr),x="exclusive"+o,w="exclType"+o,g="exclIsNumber"+o,S="' + "+(k="op"+o)+" + '";s+=" var schemaExcl"+o+" = "+y+"; ",s+=" var "+x+"; var "+w+" = typeof "+(y="schemaExcl"+o)+"; if ("+w+" != 'boolean' && "+w+" != 'undefined' && "+w+" != 'number') { ";var $;E=v;($=$||[]).push(s),s="",!1!==e.createErrors?(s+=" { keyword: '"+(E||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&&(s+=" , message: '"+v+" should be boolean' "),e.opts.verbose&&(s+=" , schema: validate.schema"+h+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),s+=" } "):s+=" {} ";var M=s;s=$.pop(),!e.compositeRule&&l?e.async?s+=" throw new ValidationError(["+M+"]); ":s+=" validate.errors = ["+M+"]; return false; ":s+=" var err = "+M+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",s+=" } else if ( ",n&&(s+=" ("+t+" !== undefined && typeof "+t+" != 'number') || "),s+=" "+w+" == 'number' ? ( ("+x+" = "+t+" === undefined || "+y+" "+b+"= "+t+") ? "+d+" "+P+"= "+y+" : "+d+" "+P+" "+t+" ) : ( ("+x+" = "+y+" === true) ? "+d+" "+P+"= "+t+" : "+d+" "+P+" "+t+" ) || "+d+" !== "+d+") { var op"+o+" = "+x+" ? '"+b+"' : '"+b+"='; ",void 0===m&&(E=v,u=e.errSchemaPath+"/"+v,t=y,n=f)}else{S=b;if((g="number"==typeof p)&&n){var k="'"+S+"'";s+=" if ( ",n&&(s+=" ("+t+" !== undefined && typeof "+t+" != 'number') || "),s+=" ( "+t+" === undefined || "+p+" "+b+"= "+t+" ? "+d+" "+P+"= "+p+" : "+d+" "+P+" "+t+" ) || "+d+" !== "+d+") { "}else{g&&void 0===m?(x=!0,E=v,u=e.errSchemaPath+"/"+v,t=p,P+="="):(g&&(t=Math[c?"min":"max"](p,m)),p===(!g||t)?(x=!0,E=v,u=e.errSchemaPath+"/"+v,P+="="):(x=!1,S+="="));k="'"+S+"'";s+=" if ( ",n&&(s+=" ("+t+" !== undefined && typeof "+t+" != 'number') || "),s+=" "+d+" "+P+" "+t+" || "+d+" !== "+d+") { "}}E=E||r,($=$||[]).push(s),s="",!1!==e.createErrors?(s+=" { keyword: '"+(E||"_limit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { comparison: "+k+", limit: "+t+", exclusive: "+x+" } ",!1!==e.opts.messages&&(s+=" , message: 'should be "+S+" ",s+=n?"' + "+t:t+"'"),e.opts.verbose&&(s+=" , schema:  ",s+=n?"validate.schema"+h:""+m,s+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),s+=" } "):s+=" {} ";M=s;return s=$.pop(),!e.compositeRule&&l?e.async?s+=" throw new ValidationError(["+M+"]); ":s+=" validate.errors = ["+M+"]; return false; ":s+=" var err = "+M+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",s+=" } ",l&&(s+=" else { "),s};