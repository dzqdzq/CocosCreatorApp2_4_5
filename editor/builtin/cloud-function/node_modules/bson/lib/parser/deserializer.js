"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deserialize=void 0;const e=require("buffer"),r=require("../binary"),t=require("../code"),n=require("../constants"),o=require("../db_ref"),i=require("../decimal128"),s=require("../double"),l=require("../int_32"),f=require("../long"),a=require("../max_key"),c=require("../min_key"),u=require("../objectid"),w=require("../regexp"),h=require("../symbol"),g=require("../timestamp"),b=require("../validate_utf8"),_=f.Long.fromNumber(n.JS_INT_MAX),E=f.Long.fromNumber(n.JS_INT_MIN),B={};function d(e,r,t){return r?(null==r[e]&&(r[e]=new Function(e)),r[e].bind(t)):new Function(e)}exports.deserialize=function(A,S,O){const y=(S=null==S?{}:S)&&S.index?S.index:0,N=A[y]|A[y+1]<<8|A[y+2]<<16|A[y+3]<<24;if(N<5)throw new Error(`bson size must be >= 5, is ${N}`);if(S.allowObjectSmallerThanBufferSize&&A.length<N)throw new Error(`buffer length ${A.length} must be >= bson size ${N}`);if(!S.allowObjectSmallerThanBufferSize&&A.length!==N)throw new Error(`buffer length ${A.length} must === bson size ${N}`);if(N+y>A.byteLength)throw new Error(`(bson size ${N} + options.index ${y} must be <= buffer length ${A.byteLength})`);if(0!==A[y+N-1])throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return function A(S,O,y,N=!1){const p=null!=y.evalFunctions&&y.evalFunctions,m=null!=y.cacheFunctions&&y.cacheFunctions,D=null==y.fieldsAsRaw?null:y.fieldsAsRaw,T=null!=y.raw&&y.raw,x="boolean"==typeof y.bsonRegExp&&y.bsonRegExp,R=null!=y.promoteBuffers&&y.promoteBuffers,z=null==y.promoteLongs||y.promoteLongs,L=null==y.promoteValues||y.promoteValues,q=O;if(S.length<5)throw new Error("corrupt bson message < 5 bytes long");const I=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(I<5||I>S.length)throw new Error("corrupt bson message");const $=N?[]:{};let v=0;for(;;){const q=S[O++];if(0===q)break;let I=O;for(;0!==S[I]&&I<S.length;)I++;if(I>=S.byteLength)throw new Error("Bad BSON Document: illegal CString");const j=N?v++:S.toString("utf8",O,I);if(O=I+1,q===n.BSON_DATA_STRING){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(e<=0||e>S.length-O||0!==S[O+e-1])throw new Error("bad string length in bson");if(!b.validateUtf8(S,O,O+e-1))throw new Error("Invalid UTF-8 string in BSON document");const r=S.toString("utf8",O,O+e-1);$[j]=r,O+=e}else if(q===n.BSON_DATA_OID){const r=e.Buffer.alloc(12);S.copy(r,0,O,O+12),$[j]=new u.ObjectId(r),O+=12}else if(q===n.BSON_DATA_INT&&!1===L)$[j]=new l.Int32(S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24);else if(q===n.BSON_DATA_INT)$[j]=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;else if(q===n.BSON_DATA_NUMBER&&!1===L)$[j]=new s.Double(S.readDoubleLE(O)),O+=8;else if(q===n.BSON_DATA_NUMBER)$[j]=S.readDoubleLE(O),O+=8;else if(q===n.BSON_DATA_DATE){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24,r=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;$[j]=new Date(new f.Long(e,r).toNumber())}else if(q===n.BSON_DATA_BOOLEAN){if(0!==S[O]&&1!==S[O])throw new Error("illegal boolean type value");$[j]=1===S[O++]}else if(q===n.BSON_DATA_OBJECT){const e=O,r=S[O]|S[O+1]<<8|S[O+2]<<16|S[O+3]<<24;if(r<=0||r>S.length-O)throw new Error("bad embedded document length in bson");$[j]=T?S.slice(O,O+r):A(S,e,y,!1),O+=r}else if(q===n.BSON_DATA_ARRAY){const e=O,r=S[O]|S[O+1]<<8|S[O+2]<<16|S[O+3]<<24;let t=y;const n=O+r;if(D&&D[j]){t={};for(const e in y)t[e]=y[e];t.raw=!0}if($[j]=A(S,e,t,!0),0!==S[(O+=r)-1])throw new Error("invalid array terminator byte");if(O!==n)throw new Error("corrupted array bson")}else if(q===n.BSON_DATA_UNDEFINED)$[j]=void 0;else if(q===n.BSON_DATA_NULL)$[j]=null;else if(q===n.BSON_DATA_LONG){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24,r=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24,t=new f.Long(e,r);$[j]=z&&!0===L&&t.lessThanOrEqual(_)&&t.greaterThanOrEqual(E)?t.toNumber():t}else if(q===n.BSON_DATA_DECIMAL128){const r=e.Buffer.alloc(16);S.copy(r,0,O,O+16),O+=16;const t=new i.Decimal128(r);"toObject"in t&&"function"==typeof t.toObject?$[j]=t.toObject():$[j]=t}else if(q===n.BSON_DATA_BINARY){let t=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;const n=t,o=S[O++];if(t<0)throw new Error("Negative binary type element size found");if(t>S.byteLength)throw new Error("Binary type size larger than document size");if(null!=S.slice){if(o===r.Binary.SUBTYPE_BYTE_ARRAY){if((t=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24)<0)throw new Error("Negative binary type element size found for subtype 0x02");if(t>n-4)throw new Error("Binary type with subtype 0x02 contains too long binary size");if(t<n-4)throw new Error("Binary type with subtype 0x02 contains too short binary size")}$[j]=R&&L?S.slice(O,O+t):new r.Binary(S.slice(O,O+t),o)}else{const i=e.Buffer.alloc(t);if(o===r.Binary.SUBTYPE_BYTE_ARRAY){if((t=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24)<0)throw new Error("Negative binary type element size found for subtype 0x02");if(t>n-4)throw new Error("Binary type with subtype 0x02 contains too long binary size");if(t<n-4)throw new Error("Binary type with subtype 0x02 contains too short binary size")}for(I=0;I<t;I++)i[I]=S[O+I];$[j]=R&&L?i:new r.Binary(i,o)}O+=t}else if(q===n.BSON_DATA_REGEXP&&!1===x){for(I=O;0!==S[I]&&I<S.length;)I++;if(I>=S.length)throw new Error("Bad BSON Document: illegal CString");const e=S.toString("utf8",O,I);for(I=O=I+1;0!==S[I]&&I<S.length;)I++;if(I>=S.length)throw new Error("Bad BSON Document: illegal CString");const r=S.toString("utf8",O,I);O=I+1;const t=new Array(r.length);for(I=0;I<r.length;I++)switch(r[I]){case"m":t[I]="m";break;case"s":t[I]="g";break;case"i":t[I]="i"}$[j]=new RegExp(e,t.join(""))}else if(q===n.BSON_DATA_REGEXP&&!0===x){for(I=O;0!==S[I]&&I<S.length;)I++;if(I>=S.length)throw new Error("Bad BSON Document: illegal CString");const e=S.toString("utf8",O,I);for(I=O=I+1;0!==S[I]&&I<S.length;)I++;if(I>=S.length)throw new Error("Bad BSON Document: illegal CString");const r=S.toString("utf8",O,I);O=I+1,$[j]=new w.BSONRegExp(e,r)}else if(q===n.BSON_DATA_SYMBOL){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(e<=0||e>S.length-O||0!==S[O+e-1])throw new Error("bad string length in bson");const r=S.toString("utf8",O,O+e-1);$[j]=L?r:new h.BSONSymbol(r),O+=e}else if(q===n.BSON_DATA_TIMESTAMP){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24,r=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;$[j]=new g.Timestamp(e,r)}else if(q===n.BSON_DATA_MIN_KEY)$[j]=new c.MinKey;else if(q===n.BSON_DATA_MAX_KEY)$[j]=new a.MaxKey;else if(q===n.BSON_DATA_CODE){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(e<=0||e>S.length-O||0!==S[O+e-1])throw new Error("bad string length in bson");const r=S.toString("utf8",O,O+e-1);$[j]=p?m?d(r,B,$):d(r):new t.Code(r),O+=e}else if(q===n.BSON_DATA_CODE_W_SCOPE){const e=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(e<13)throw new Error("code_w_scope total size shorter minimum expected length");const r=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(r<=0||r>S.length-O||0!==S[O+r-1])throw new Error("bad string length in bson");const n=S.toString("utf8",O,O+r-1),o=O+=r,i=S[O]|S[O+1]<<8|S[O+2]<<16|S[O+3]<<24,s=A(S,o,y,!1);if(O+=i,e<8+i+r)throw new Error("code_w_scope total size is too short, truncating scope");if(e>8+i+r)throw new Error("code_w_scope total size is too long, clips outer document");p?($[j]=m?d(n,B,$):d(n),$[j].scope=s):$[j]=new t.Code(n,s)}else{if(q!==n.BSON_DATA_DBPOINTER)throw new Error("Detected unknown BSON type "+q.toString(16)+' for fieldname "'+j+'"');{const r=S[O++]|S[O++]<<8|S[O++]<<16|S[O++]<<24;if(r<=0||r>S.length-O||0!==S[O+r-1])throw new Error("bad string length in bson");if(!b.validateUtf8(S,O,O+r-1))throw new Error("Invalid UTF-8 string in BSON document");const t=S.toString("utf8",O,O+r-1);O+=r;const n=e.Buffer.alloc(12);S.copy(n,0,O,O+12);const i=new u.ObjectId(n);O+=12,$[j]=new o.DBRef(t,i)}}}if(I!==O-q){if(N)throw new Error("corrupt array bson");throw new Error("corrupt object bson")}const j=Object.keys($).filter(e=>e.startsWith("$"));let M=!0;if(j.forEach(e=>{-1===["$ref","$id","$db"].indexOf(e)&&(M=!1)}),!M)return $;if(o.isDBRefLike($)){const e=Object.assign({},$);return delete e.$ref,delete e.$id,delete e.$db,new o.DBRef($.$ref,$.$id,$.$db,e)}return $}(A,y,S,O)};