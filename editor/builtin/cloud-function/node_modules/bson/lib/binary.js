"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Binary=void 0;const e=require("buffer"),t=require("./ensure_buffer"),r=require("./uuid");class i{constructor(r,n){if(!(null==r||"string"==typeof r||ArrayBuffer.isView(r)||r instanceof ArrayBuffer||Array.isArray(r)))throw new TypeError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");this.sub_type=null!==n&&void 0!==n?n:i.BSON_BINARY_SUBTYPE_DEFAULT,null==r?(this.buffer=e.Buffer.alloc(i.BUFFER_SIZE),this.position=0):("string"==typeof r?this.buffer=e.Buffer.from(r,"binary"):Array.isArray(r)?this.buffer=e.Buffer.from(r):this.buffer=t.ensureBuffer(r),this.position=this.buffer.byteLength)}put(t){if("string"==typeof t&&1!==t.length)throw new TypeError("only accepts single character String");if("number"!=typeof t&&1!==t.length)throw new TypeError("only accepts single character Uint8Array or Array");let r;if((r="string"==typeof t?t.charCodeAt(0):"number"==typeof t?t:t[0])<0||r>255)throw new TypeError("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.length>this.position)this.buffer[this.position++]=r;else{const t=e.Buffer.alloc(i.BUFFER_SIZE+this.buffer.length);this.buffer.copy(t,0,0,this.buffer.length),this.buffer=t,this.buffer[this.position++]=r}}write(r,i){if(i="number"==typeof i?i:this.position,this.buffer.length<i+r.length){const t=e.Buffer.alloc(this.buffer.length+r.length);this.buffer.copy(t,0,0,this.buffer.length),this.buffer=t}ArrayBuffer.isView(r)?(this.buffer.set(t.ensureBuffer(r),i),this.position=i+r.byteLength>this.position?i+r.length:this.position):"string"==typeof r&&(this.buffer.write(r,i,r.length,"binary"),this.position=i+r.length>this.position?i+r.length:this.position)}read(e,t){return t=t&&t>0?t:this.position,this.buffer.slice(e,e+t)}value(e){return(e=!!e)&&this.buffer.length===this.position?this.buffer:e?this.buffer.slice(0,this.position):this.buffer.toString("binary",0,this.position)}length(){return this.position}toJSON(){return this.buffer.toString("base64")}toString(e){return this.buffer.toString(e)}toExtendedJSON(e){e=e||{};const t=this.buffer.toString("base64"),r=Number(this.sub_type).toString(16);return e.legacy?{$binary:t,$type:1===r.length?"0"+r:r}:{$binary:{base64:t,subType:1===r.length?"0"+r:r}}}static fromExtendedJSON(t,n){let s,f;if(n=n||{},"$binary"in t?n.legacy&&"string"==typeof t.$binary&&"$type"in t?(f=t.$type?parseInt(t.$type,16):0,s=e.Buffer.from(t.$binary,"base64")):"string"!=typeof t.$binary&&(f=t.$binary.subType?parseInt(t.$binary.subType,16):0,s=e.Buffer.from(t.$binary.base64,"base64")):"$uuid"in t&&(f=4,s=e.Buffer.from(r.parseUUID(t.$uuid))),!s)throw new TypeError(`Unexpected Binary Extended JSON format ${JSON.stringify(t)}`);return new i(s,f)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`Binary("${this.value(!0).toString("hex")}", ${this.sub_type})`}}exports.Binary=i,i.BSON_BINARY_SUBTYPE_DEFAULT=0,i.BUFFER_SIZE=256,i.SUBTYPE_DEFAULT=0,i.SUBTYPE_FUNCTION=1,i.SUBTYPE_BYTE_ARRAY=2,i.SUBTYPE_UUID_OLD=3,i.SUBTYPE_UUID=4,i.SUBTYPE_MD5=5,i.SUBTYPE_USER_DEFINED=128,Object.defineProperty(i.prototype,"_bsontype",{value:"Binary"});