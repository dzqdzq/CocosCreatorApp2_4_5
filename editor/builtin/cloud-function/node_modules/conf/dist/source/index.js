"use strict";var e,t,r,i,s,o,n=this&&this.__classPrivateFieldSet||function(e,t,r){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");return t.set(e,r),r},a=this&&this.__classPrivateFieldGet||function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return t.get(e)};Object.defineProperty(exports,"__esModule",{value:!0});const c=require("fs"),h=require("path"),f=require("crypto"),l=require("assert"),p=require("events"),u=require("dot-prop"),d=require("make-dir"),y=require("pkg-up"),g=require("env-paths"),m=require("atomically"),w=require("ajv"),_=require("debounce-fn"),v=require("semver"),b=require("onetime"),j="aes-256-cbc",E=()=>Object.create(null);delete require.cache[__filename];const S=h.dirname(null!==(t=null===(e=module.parent)||void 0===e?void 0:e.filename)&&void 0!==t?t:"."),N=(e,t)=>{const r=typeof t;if(new Set(["undefined","symbol","function"]).has(r))throw new TypeError(`Setting a value of type \`${r}\` for key \`${e}\` is not allowed as it's not supported by JSON`)},D="__internal__",P=`${D}.migrations.version`;class q{constructor(e={}){var t;r.set(this,void 0),i.set(this,void 0),s.set(this,void 0),o.set(this,{}),this._deserialize=(e=>JSON.parse(e)),this._serialize=(e=>JSON.stringify(e,null,"\t"));const f={configName:"config",fileExtension:"json",projectSuffix:"nodejs",clearInvalidConfig:!0,accessPropertiesByDotNotation:!0,...e},u=b(()=>{const e=y.sync({cwd:S}),t=e&&JSON.parse(c.readFileSync(e,"utf8"));return null!==t&&void 0!==t?t:{}});if(!f.cwd){if(f.projectName||(f.projectName=u().name),!f.projectName)throw new Error("Project name could not be inferred. Please specify the `projectName` option.");f.cwd=g(f.projectName,{suffix:f.projectSuffix}).config}if(n(this,s,f),f.schema){if("object"!=typeof f.schema)throw new TypeError("The `schema` option must be an object.");const e=new w({allErrors:!0,format:"full",useDefaults:!0,errorDataPath:"property"}),t={type:"object",properties:f.schema};n(this,r,e.compile(t));for(const[e,t]of Object.entries(f.schema))(null===t||void 0===t?void 0:t.default)&&(a(this,o)[e]=t.default)}f.defaults&&n(this,o,{...a(this,o),...f.defaults}),f.serialize&&(this._serialize=f.serialize),f.deserialize&&(this._deserialize=f.deserialize),this.events=new p.EventEmitter,n(this,i,f.encryptionKey);const d=f.fileExtension?`.${f.fileExtension}`:"";this.path=h.resolve(f.cwd,`${null!==(t=f.configName)&&void 0!==t?t:"config"}${d}`);const m=this.store,_=Object.assign(E(),f.defaults,m);this._validate(_);try{l.deepEqual(m,_)}catch(e){this.store=_}if(f.watch&&this._watch(),f.migrations){if(f.projectVersion||(f.projectVersion=u().version),!f.projectVersion)throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");this._migrate(f.migrations,f.projectVersion)}}get(e,t){return a(this,s).accessPropertiesByDotNotation?this._get(e,t):e in this.store?this.store[e]:t}set(e,t){if("string"!=typeof e&&"object"!=typeof e)throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof e}`);if("object"!=typeof e&&void 0===t)throw new TypeError("Use `delete()` to clear values");if(this._containsReservedKey(e))throw new TypeError(`Please don't use the ${D} key, as it's used to manage this module internal operations.`);const{store:r}=this,i=(e,t)=>{N(e,t),a(this,s).accessPropertiesByDotNotation?u.set(r,e,t):r[e]=t};if("object"==typeof e){const t=e;for(const[e,r]of Object.entries(t))i(e,r)}else i(e,t);this.store=r}has(e){return a(this,s).accessPropertiesByDotNotation?u.has(this.store,e):e in this.store}reset(...e){for(const t of e)a(this,o)[t]&&this.set(t,a(this,o)[t])}delete(e){const{store:t}=this;a(this,s).accessPropertiesByDotNotation?u.delete(t,e):delete t[e],this.store=t}clear(){this.store=E()}onDidChange(e,t){if("string"!=typeof e)throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof e}`);if("function"!=typeof t)throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof t}`);return this._handleChange(()=>this.get(e),t)}onDidAnyChange(e){if("function"!=typeof e)throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof e}`);return this._handleChange(()=>this.store,e)}get size(){return Object.keys(this.store).length}get store(){try{const e=c.readFileSync(this.path,a(this,i)?null:"utf8"),t=this._encryptData(e),r=this._deserialize(t);return this._validate(r),Object.assign(E(),r)}catch(e){if("ENOENT"===e.code)return this._ensureDirectory(),E();if(a(this,s).clearInvalidConfig&&"SyntaxError"===e.name)return E();throw e}}set store(e){this._ensureDirectory(),this._validate(e),this._write(e),this.events.emit("change")}*[(r=new WeakMap,i=new WeakMap,s=new WeakMap,o=new WeakMap,Symbol.iterator)](){for(const[e,t]of Object.entries(this.store))yield[e,t]}_encryptData(e){if(!a(this,i))return e.toString();try{if(a(this,i))try{if(":"===e.slice(16,17).toString()){const t=e.slice(0,16),r=f.pbkdf2Sync(a(this,i),t.toString(),1e4,32,"sha512"),s=f.createDecipheriv(j,r,t);e=Buffer.concat([s.update(Buffer.from(e.slice(17))),s.final()]).toString("utf8")}else{const t=f.createDecipher(j,a(this,i));e=Buffer.concat([t.update(Buffer.from(e)),t.final()]).toString("utf8")}}catch(e){}}catch(e){}return e.toString()}_handleChange(e,t){let r=e();const i=()=>{const i=r,s=e();try{l.deepEqual(s,i)}catch(e){r=s,t.call(this,s,i)}};return this.events.on("change",i),()=>this.events.removeListener("change",i)}_validate(e){if(!a(this,r))return;if(a(this,r).call(this,e)||!a(this,r).errors)return;const t=a(this,r).errors.reduce((e,{dataPath:t,message:r=""})=>e+` \`${t.slice(1)}\` ${r};`,"");throw new Error("Config schema violation:"+t.slice(0,-1))}_ensureDirectory(){d.sync(h.dirname(this.path))}_write(e){let t=this._serialize(e);if(a(this,i)){const e=f.randomBytes(16),r=f.pbkdf2Sync(a(this,i),e.toString(),1e4,32,"sha512"),s=f.createCipheriv(j,r,e);t=Buffer.concat([e,Buffer.from(":"),s.update(Buffer.from(t)),s.final()])}if(process.env.SNAP)c.writeFileSync(this.path,t);else try{m.writeFileSync(this.path,t)}catch(e){if("EXDEV"===e.code)return c.writeFileSync(this.path,t),void 0;throw e}}_watch(){this._ensureDirectory(),c.existsSync(this.path)||this._write(E()),c.watch(this.path,{persistent:!1},_(()=>{this.events.emit("change")},{wait:100}))}_migrate(e,t){let r=this._get(P,"0.0.0");const i=Object.keys(e).filter(e=>this._shouldPerformMigration(e,r,t));let s={...this.store};for(const t of i)try{(0,e[t])(this),this._set(P,t),r=t,s={...this.store}}catch(e){throw this.store=s,new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${e}`)}!this._isVersionInRangeFormat(r)&&v.eq(r,t)||this._set(P,t)}_containsReservedKey(e){if("object"==typeof e){if(Object.keys(e)[0]===D)return!0}return"string"==typeof e&&(!!a(this,s).accessPropertiesByDotNotation&&!!e.startsWith(`${D}.`))}_isVersionInRangeFormat(e){return null===v.clean(e)}_shouldPerformMigration(e,t,r){return this._isVersionInRangeFormat(e)?("0.0.0"===t||!v.satisfies(t,e))&&v.satisfies(r,e):!v.lte(e,t)&&!v.gt(e,r)}_get(e,t){return u.get(this.store,e,t)}_set(e,t){const{store:r}=this;u.set(r,e,t),this.store=r}}exports.default=q,module.exports=q,module.exports.default=q;