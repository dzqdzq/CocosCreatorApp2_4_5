"use strict";const t=require("yallist"),e=Symbol("max"),s=Symbol("length"),i=Symbol("lengthCalculator"),h=Symbol("allowStale"),n=Symbol("maxAge"),r=Symbol("dispose"),o=Symbol("noDisposeOnSet"),a=Symbol("lruList"),l=Symbol("cache"),u=Symbol("updateAgeOnGet"),m=()=>1;const g=(t,e,s)=>{const i=t[l].get(e);if(i){const e=i.value;if(c(t,e)){if(y(t,i),!t[h])return}else s&&(t[u]&&(i.value.now=Date.now()),t[a].unshiftNode(i));return e.value}},c=(t,e)=>{if(!e||!e.maxAge&&!t[n])return!1;const s=Date.now()-e.now;return e.maxAge?s>e.maxAge:t[n]&&s>t[n]},f=t=>{if(t[s]>t[e])for(let i=t[a].tail;t[s]>t[e]&&null!==i;){const e=i.prev;y(t,i),i=e}},y=(t,e)=>{if(e){const i=e.value;t[r]&&t[r](i.key,i.value),t[s]-=i.length,t[l].delete(i.key),t[a].removeNode(e)}};class p{constructor(t,e,s,i,h){this.key=t,this.value=e,this.length=s,this.now=i,this.maxAge=h||0}}const v=(t,e,s,i)=>{let n=s.value;c(t,n)&&(y(t,s),t[h]||(n=void 0)),n&&e.call(i,n.value,n.key,t)};module.exports=class{constructor(t){if("number"==typeof t&&(t={max:t}),t||(t={}),t.max&&("number"!=typeof t.max||t.max<0))throw new TypeError("max must be a non-negative number");this[e]=t.max||1/0;const s=t.length||m;if(this[i]="function"!=typeof s?m:s,this[h]=t.stale||!1,t.maxAge&&"number"!=typeof t.maxAge)throw new TypeError("maxAge must be a number");this[n]=t.maxAge||0,this[r]=t.dispose,this[o]=t.noDisposeOnSet||!1,this[u]=t.updateAgeOnGet||!1,this.reset()}set max(t){if("number"!=typeof t||t<0)throw new TypeError("max must be a non-negative number");this[e]=t||1/0,f(this)}get max(){return this[e]}set allowStale(t){this[h]=!!t}get allowStale(){return this[h]}set maxAge(t){if("number"!=typeof t)throw new TypeError("maxAge must be a non-negative number");this[n]=t,f(this)}get maxAge(){return this[n]}set lengthCalculator(t){"function"!=typeof t&&(t=m),t!==this[i]&&(this[i]=t,this[s]=0,this[a].forEach(t=>{t.length=this[i](t.value,t.key),this[s]+=t.length})),f(this)}get lengthCalculator(){return this[i]}get length(){return this[s]}get itemCount(){return this[a].length}rforEach(t,e){e=e||this;for(let s=this[a].tail;null!==s;){const i=s.prev;v(this,t,s,e),s=i}}forEach(t,e){e=e||this;for(let s=this[a].head;null!==s;){const i=s.next;v(this,t,s,e),s=i}}keys(){return this[a].toArray().map(t=>t.key)}values(){return this[a].toArray().map(t=>t.value)}reset(){this[r]&&this[a]&&this[a].length&&this[a].forEach(t=>this[r](t.key,t.value)),this[l]=new Map,this[a]=new t,this[s]=0}dump(){return this[a].map(t=>!c(this,t)&&{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[a]}set(t,h,u){if((u=u||this[n])&&"number"!=typeof u)throw new TypeError("maxAge must be a number");const m=u?Date.now():0,g=this[i](h,t);if(this[l].has(t)){if(g>this[e])return y(this,this[l].get(t)),!1;const i=this[l].get(t).value;return this[r]&&(this[o]||this[r](t,i.value)),i.now=m,i.maxAge=u,i.value=h,this[s]+=g-i.length,i.length=g,this.get(t),f(this),!0}const c=new p(t,h,g,m,u);return c.length>this[e]?(this[r]&&this[r](t,h),!1):(this[s]+=c.length,this[a].unshift(c),this[l].set(t,this[a].head),f(this),!0)}has(t){if(!this[l].has(t))return!1;const e=this[l].get(t).value;return!c(this,e)}get(t){return g(this,t,!0)}peek(t){return g(this,t,!1)}pop(){const t=this[a].tail;return t?(y(this,t),t.value):null}del(t){y(this,this[l].get(t))}load(t){this.reset();const e=Date.now();for(let s=t.length-1;s>=0;s--){const i=t[s],h=i.e||0;if(0===h)this.set(i.k,i.v);else{const t=h-e;t>0&&this.set(i.k,i.v,t)}}}prune(){this[l].forEach((t,e)=>g(this,e,!1))}};