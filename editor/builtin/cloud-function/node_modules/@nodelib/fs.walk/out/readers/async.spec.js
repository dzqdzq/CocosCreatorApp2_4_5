"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("assert"),r=require("path"),t=require("sinon"),n=require("../settings"),s=require("../tests"),i=require("./async");class d extends i.default{constructor(e,r=new n.default){super(e,r),this._scandir=t.stub()}get scandir(){return this._scandir}}describe("Readers â†’ Async",()=>{describe(".read",()=>{it('should emit "error" event when the first call of scandir is broken',r=>{const t=new d("non-exist-directory");t.scandir.yields(s.EPERM_ERRNO),t.onError(t=>{e.ok(t),r()}),t.read()}),it('should emit "end" event when the first call of scandir is broken but this error can be suppressed',e=>{const r=new n.default({errorFilter:e=>"EPERM"===e.code}),t=new d("non-exist-directory",r);t.scandir.yields(s.EPERM_ERRNO),t.onEnd(()=>{e()}),t.read()}),it("should do not emit events after first broken scandir call",r=>{const t=new d("directory"),n=s.buildFakeDirectoryEntry({name:"a",path:"directory/a"}),i=s.buildFakeDirectoryEntry({name:"b",path:"directory/b"});t.scandir.onFirstCall().yields(null,[n,i]),t.scandir.onSecondCall().yieldsAsync(s.EPERM_ERRNO),t.scandir.onThirdCall().yieldsAsync(s.EPERM_ERRNO),t.onError(t=>{e.ok(t),r()}),t.read()}),it("should return entries",r=>{const t=new d("directory"),n=s.buildFakeDirectoryEntry(),i=s.buildFakeFileEntry();t.scandir.onFirstCall().yields(null,[n]),t.scandir.onSecondCall().yields(null,[i]);const o=[];t.onEntry(e=>o.push(e)),t.onEnd(()=>{e.deepStrictEqual(o,[n,i]),r()}),t.read()}),it("should push to results only directories",r=>{const t=new n.default({entryFilter:e=>!e.dirent.isFile()}),i=new d("directory",t),o=s.buildFakeDirectoryEntry(),a=s.buildFakeFileEntry();i.scandir.onFirstCall().yields(null,[o]),i.scandir.onSecondCall().yields(null,[a]);const l=[];i.onEntry(e=>l.push(e)),i.onEnd(()=>{e.deepStrictEqual(l,[o]),r()}),i.read()}),it("should do not read root directory",r=>{const t=new n.default({deepFilter:()=>!1}),i=new d("directory",t),o=s.buildFakeDirectoryEntry(),a=s.buildFakeFileEntry();i.scandir.onFirstCall().yields(null,[o]),i.scandir.onSecondCall().yields(null,[a]);const l=[];i.onEntry(e=>l.push(e)),i.onEnd(()=>{e.deepStrictEqual(l,[o]),r()}),i.read()}),it("should set base path to entry when the `basePath` option is exist",t=>{const i=new n.default({basePath:"base"}),o=new d("directory",i),a=s.buildFakeDirectoryEntry(),l=s.buildFakeFileEntry();o.scandir.onFirstCall().yields(null,[a]),o.scandir.onSecondCall().yields(null,[l]);const c=[];o.onEntry(e=>c.push(e)),o.onEnd(()=>{e.strictEqual(c[0].path,r.join("base",a.name)),e.strictEqual(c[1].path,r.join("base","fake",l.name)),t()}),o.read()}),it("should set base path to entry when the `basePath` option is exist and value is an empty string",t=>{const i=new n.default({basePath:""}),o=new d("directory",i),a=s.buildFakeDirectoryEntry(),l=s.buildFakeFileEntry();o.scandir.onFirstCall().yields(null,[a]),o.scandir.onSecondCall().yields(null,[l]);const c=[];o.onEntry(e=>c.push(e)),o.onEnd(()=>{e.strictEqual(c[0].path,r.join(a.name)),e.strictEqual(c[1].path,r.join("fake",l.name)),t()}),o.read()})}),describe(".destroy",()=>{it("should do not emit entries after destroy",r=>{const t=new d("directory"),n=s.buildFakeDirectoryEntry({name:"a",path:"directory/a"}),i=s.buildFakeFileEntry();t.scandir.onFirstCall().yields(null,[n]),t.scandir.onSecondCall().yields(null,[i]),t.onEntry(r=>{"a"===r.name?t.destroy():e.fail("should do not emit entries after destroy")}),t.onEnd(()=>{r()}),t.read()}),it('should mark stream as "destroyed" after first destroy',()=>{const r=new d("directory");r.destroy(),e.ok(r.isDestroyed)}),it("should throw an error when trying to destroy reader twice",()=>{const r=new d("directory");r.destroy(),e.throws(()=>r.destroy(),/The reader is already destroyed/)})})});