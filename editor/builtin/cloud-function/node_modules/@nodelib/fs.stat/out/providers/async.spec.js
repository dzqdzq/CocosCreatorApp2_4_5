"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("assert"),s=require("sinon"),e=require("../../../fs.macchiato"),l=require("../settings"),i=require("./async");describe("Providers â†’ Async",()=>{describe(".read",()=>{it("should return lstat for non-symlink entry",n=>{const r=s.stub().yields(null,new e.Stats),o=new l.default({fs:{lstat:r}});i.read("filepath",o,(s,e)=>{t.strictEqual(s,null),t.strictEqual(e.ino,0),n()})}),it('should return lstat for symlink entry when the "followSymbolicLink" option is disabled',n=>{const r=s.stub().yields(null,new e.Stats({isSymbolicLink:!0})),o=new l.default({followSymbolicLink:!1,fs:{lstat:r}});i.read("filepath",o,(s,e)=>{t.strictEqual(s,null),t.strictEqual(e.ino,0),n()})}),it("should return stat for symlink entry",n=>{const r=s.stub().yields(null,new e.Stats({isSymbolicLink:!0})),o=s.stub().yields(null,new e.Stats({ino:1})),a=new l.default({fs:{lstat:r,stat:o}});i.read("filepath",a,(s,e)=>{t.strictEqual(s,null),t.strictEqual(e.ino,1),n()})}),it('should return marked stat for symlink entry when the "markSymbolicLink" option is enabled',n=>{const r=s.stub().yields(null,new e.Stats({isSymbolicLink:!0})),o=s.stub().yields(null,new e.Stats({ino:1})),a=new l.default({fs:{lstat:r,stat:o},markSymbolicLink:!0});i.read("filepath",a,(s,e)=>{t.strictEqual(s,null),t.strictEqual(e.isSymbolicLink(),!0),n()})}),it('should return lstat for broken symlink entry when the "throwErrorOnBrokenSymbolicLink" option is disabled',n=>{const r=s.stub().yields(null,new e.Stats({isSymbolicLink:!0})),o=s.stub().yields(new Error),a=new l.default({fs:{lstat:r,stat:o},throwErrorOnBrokenSymbolicLink:!1});i.read("filepath",a,(s,e)=>{t.strictEqual(s,null),t.strictEqual(e.ino,0),n()})}),it("should throw an error when symlink entry is broken",n=>{const r=s.stub().yields(null,new e.Stats({isSymbolicLink:!0})),o=s.stub().yields(new Error("broken")),a=new l.default({fs:{lstat:r,stat:o}});i.read("filepath",a,s=>{t.strictEqual(s.message,"broken"),n()})})})});