"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("assert"),r=require("path"),e=require("sinon"),s=require("../../../fs.macchiato"),i=require("../constants"),n=require("../settings"),o=require("./sync"),a=r.join("root","first.txt"),d=r.join("root","second.txt");describe("Providers â†’ Sync",()=>{describe(".read",()=>{it("should call correct method based on Node.js version",()=>{const r=e.stub().returns([]),s=new n.default({fs:{readdirSync:r}}),a=o.read("root",s);t.deepStrictEqual(a,[]),i.IS_SUPPORT_READDIR_WITH_FILE_TYPES?t.deepStrictEqual(r.args,[["root",{withFileTypes:!0}]]):t.deepStrictEqual(r.args,[["root"]])}),it("should always use `readdir` method when the `stats` option is enabled",()=>{const r=e.stub().returns([]),s=new n.default({fs:{readdirSync:r},stats:!0});o.read("root",s),t.deepStrictEqual(r.args,[["root"]])})}),describe(".readdirWithFileTypes",()=>{it("should return entries",()=>{const r=new s.Dirent({name:"first.txt"}),i=e.stub().returns([r]),d=new n.default({fs:{readdirSync:i}}),l=[{dirent:r,name:"first.txt",path:a}],c=o.readdirWithFileTypes("root",d);t.deepStrictEqual(i.args,[["root",{withFileTypes:!0}]]),t.deepStrictEqual(c,l)}),it('should call fs.stat for symbolic link when the "followSymbolicLink" option is enabled',()=>{const r=new s.Dirent({name:"first.txt"}),i=new s.Dirent({name:"second.txt",isSymbolicLink:!0}),a=new s.Stats,l=e.stub().returns([r,i]),c=e.stub().returns(a),u=new n.default({followSymbolicLinks:!0,fs:{readdirSync:l,statSync:c}}),S=o.readdirWithFileTypes("root",u);t.strictEqual(S.length,2),t.deepStrictEqual(c.args,[[d]]),t.ok(!S[1].dirent.isSymbolicLink())}),it('should return lstat for broken symbolic link when the "throwErrorOnBrokenSymbolicLink" option is disabled',()=>{const r=new s.Dirent({name:"first.txt",isSymbolicLink:!0}),i=e.stub().returns([r]),a=new n.default({followSymbolicLinks:!0,throwErrorOnBrokenSymbolicLink:!1,fs:{readdirSync:i,statSync:()=>{throw new Error("error")}}}),d=o.readdirWithFileTypes("root",a);t.strictEqual(d.length,1)}),it('should throw an error fro broken symbolic link when the "throwErrorOnBrokenSymbolicLink" option is enabled',()=>{const r=new s.Dirent({name:"first.txt",isSymbolicLink:!0}),i=e.stub().returns([r]),a=new n.default({followSymbolicLinks:!0,throwErrorOnBrokenSymbolicLink:!0,fs:{readdirSync:i,statSync:()=>{throw new Error("error")}}});t.throws(()=>o.readdirWithFileTypes("root",a),/Error: error/)})}),describe(".readdir",()=>{it("should return entries",()=>{const r=new s.Stats,i=e.stub().returns(["first.txt"]),d=e.stub().returns(r),l=new n.default({fs:{readdirSync:i,lstatSync:d}}),c=o.readdir("root",l);t.deepStrictEqual(i.args,[["root"]]),t.strictEqual(c[0].name,"first.txt"),t.strictEqual(c[0].path,a),t.strictEqual(c[0].dirent.name,"first.txt")}),it("should return entries with `stats` property",()=>{const r=new s.Stats,i=e.stub().returns(["first.txt"]),a=e.stub().returns(r),d=new n.default({fs:{readdirSync:i,lstatSync:a},stats:!0}),l=o.readdir("root",d);t.deepStrictEqual(l[0].stats,r)})})});