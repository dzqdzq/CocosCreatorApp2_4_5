"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("assert"),e=require("path"),r=require("sinon"),s=require("../../../fs.macchiato"),i=require("../constants"),n=require("../settings"),l=require("./async"),o=e.join("root","first.txt"),a=e.join("root","second.txt");describe("Providers â†’ Async",()=>{describe(".read",()=>{it("should call correct method based on Node.js version",e=>{const s=r.stub();s.yields(null,[]);const o=new n.default({fs:{readdir:s}});l.read("root",o,(n,l)=>{t.strictEqual(n,null),t.deepStrictEqual(l,[]),i.IS_SUPPORT_READDIR_WITH_FILE_TYPES?r.assert.match(s.args,[["root",{withFileTypes:!0},r.match.func]]):r.assert.match(s.args,[["root",r.match.func]]),e()})}),it("should always use `readdir` method when the `stats` option is enabled",e=>{const s=r.stub();s.yields(null,[]);const i=new n.default({fs:{readdir:s},stats:!0});l.read("root",i,(i,n)=>{t.strictEqual(i,null),t.deepStrictEqual(n,[]),r.assert.match(s.args,[["root",r.match.func]]),e()})})}),describe(".readdirWithFileTypes",()=>{it("should return entries",e=>{const i=new s.Dirent({name:"first.txt"}),a=r.stub();a.yields(null,[i]);const d=new n.default({fs:{readdir:a}}),c=[{dirent:i,name:"first.txt",path:o}];l.readdirWithFileTypes("root",d,(s,i)=>{t.strictEqual(s,null),r.assert.match(a.args,[["root",{withFileTypes:!0},r.match.func]]),t.deepStrictEqual(i,c),e()})}),it('should call fs.stat for symbolic link when the "followSymbolicLink" option is enabled',e=>{const i=new s.Dirent({name:"first.txt"}),o=new s.Dirent({name:"second.txt",isSymbolicLink:!0}),d=new s.Stats,c=r.stub(),u=r.stub();c.yields(null,[i,o]),u.yields(null,d);const h=new n.default({followSymbolicLinks:!0,fs:{readdir:c,stat:u}});l.readdirWithFileTypes("root",h,(s,i)=>{t.strictEqual(s,null),t.strictEqual(i.length,2),t.ok(!i[1].dirent.isSymbolicLink()),r.assert.match(u.args,[[a,r.match.func]]),e()})}),it('should return lstat for broken symbolic link when the "throwErrorOnBrokenSymbolicLink" option is disabled',e=>{const i=new s.Dirent({name:"first.txt",isSymbolicLink:!0}),o=r.stub(),a=r.stub();o.yields(null,[i]),a.yields(new Error("error"));const d=new n.default({followSymbolicLinks:!0,throwErrorOnBrokenSymbolicLink:!1,fs:{readdir:o,stat:a}});l.readdirWithFileTypes("root",d,(r,s)=>{t.strictEqual(r,null),t.strictEqual(s.length,1),t.ok(s[0].dirent.isSymbolicLink()),e()})}),it('should throw an error fro broken symbolic link when the "throwErrorOnBrokenSymbolicLink" option is enabled',e=>{const i=new s.Dirent({name:"first.txt",isSymbolicLink:!0}),o=r.stub(),a=r.stub();o.yields(null,[i]),a.yields(new Error("error"));const d=new n.default({followSymbolicLinks:!0,throwErrorOnBrokenSymbolicLink:!0,fs:{readdir:o,stat:a}});l.readdirWithFileTypes("root",d,(r,s)=>{t.strictEqual(r.message,"error"),t.strictEqual(s,void 0),e()})})}),describe(".readdir",()=>{it("should return entries",e=>{const i=new s.Stats,a=r.stub(),d=r.stub();a.yields(null,["first.txt"]),d.yields(null,i);const c=new n.default({fs:{readdir:a,lstat:d}});l.readdir("root",c,(s,i)=>{t.strictEqual(s,null),r.assert.match(a.args,[["root",r.match.func]]),r.assert.match(d.args,[[o,r.match.func]]),t.strictEqual(i[0].name,"first.txt"),t.strictEqual(i[0].path,o),t.strictEqual(i[0].dirent.name,"first.txt"),e()})}),it("should return entries with `stats` property",e=>{const i=new s.Stats,o=r.stub(),a=r.stub();o.yields(null,["first.txt"]),a.yields(null,i);const d=new n.default({fs:{readdir:o,lstat:a},stats:!0});l.readdir("root",d,(r,s)=>{t.strictEqual(r,null),t.deepStrictEqual(s[0].stats,i),e()})})})});